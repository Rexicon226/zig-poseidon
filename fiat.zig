// Autogenerated: 'src/ExtractionOCaml/fiat_crypto' word-by-word-montgomery -o bn254_scalar_256.zig bn254_scalar 256 21888242871839275222246405745257275088548364400416034343698204186575808495617 --lang Zig --public-function-case camelCase --public-type-case UpperCamelCase from_montgomery to_montgomery add mul square
// curve description: bn254_scalar
// machine_wordsize = 256 (from "256")
// requested operations: from_montgomery, to_montgomery, add, mul, square
// m = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001 (from "21888242871839275222246405745257275088548364400416034343698204186575808495617")
//
// NOTE: In addition to the bounds specified above each function, all
//   functions synthesized for this Montgomery arithmetic require the
//   input to be strictly less than the prime modulus (m), and also
//   require the input to be in the unique saturated representation.
//   All functions also ensure that these two properties are true of
//   return values.
//
// Computed values:
//   eval z = z[0]
//   bytes_eval z = z[0] + (z[1] << 8) + (z[2] << 16) + (z[3] << 24) + (z[4] << 32) + (z[5] << 40) + (z[6] << 48) + (z[7] << 56) + (z[8] << 64) + (z[9] << 72) + (z[10] << 80) + (z[11] << 88) + (z[12] << 96) + (z[13] << 104) + (z[14] << 112) + (z[15] << 120) + (z[16] << 128) + (z[17] << 136) + (z[18] << 144) + (z[19] << 152) + (z[20] << 160) + (z[21] << 168) + (z[22] << 176) + (z[23] << 184) + (z[24] << 192) + (z[25] << 200) + (z[26] << 208) + (z[27] << 216) + (z[28] << 224) + (z[29] << 232) + (z[30] << 240) + (z[31] << 248)
//   twos_complement_eval z = let x1 := z[0] in
//                            if x1 & (2^256-1) < 2^255 then x1 & (2^256-1) else (x1 & (2^256-1)) - 2^256

const std = @import("std");
const mode = @import("builtin").mode; // Checked arithmetic is disabled in non-debug modes to avoid side channels

inline fn cast(comptime DestType: type, target: anytype) DestType {
    @setEvalBranchQuota(10000);
    if (@typeInfo(@TypeOf(target)) == .Int) {
        const dest = @typeInfo(DestType).Int;
        const source = @typeInfo(@TypeOf(target)).Int;
        if (dest.bits < source.bits) {
            const T = std.meta.Int(source.signedness, dest.bits);
            return @bitCast(@as(T, @truncate(target)));
        }
    }
    return target;
}

// The type FiatBn254ScalarMontgomeryDomainFieldElement is a field element in the Montgomery domain.
// Bounds: [[0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]]
pub const FiatBn254ScalarMontgomeryDomainFieldElement = [1]u256;

// The type FiatBn254ScalarNonMontgomeryDomainFieldElement is a field element NOT in the Montgomery domain.
// Bounds: [[0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]]
pub const FiatBn254ScalarNonMontgomeryDomainFieldElement = [1]u256;

/// The function fiatBn254ScalarAddcarryxU256 is an addition with carry.
///
/// Postconditions:
///   out1 = (arg1 + arg2 + arg3) mod 2^256
///   out2 = ⌊(arg1 + arg2 + arg3) / 2^256⌋
///
/// Input Bounds:
///   arg1: [0x0 ~> 0x1]
///   arg2: [0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]
///   arg3: [0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]
/// Output Bounds:
///   out1: [0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]
///   out2: [0x0 ~> 0x1]
pub fn fiatBn254ScalarAddcarryxU256(out1: *u256, out2: *u1, arg1: u1, arg2: u256, arg3: u256) void {
    @setRuntimeSafety(mode == .Debug);

    const x1 = ((cast(u512, arg1) + cast(u512, arg2)) + cast(u512, arg3));
    const x2 = cast(u256, (x1 & cast(u512, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)));
    const x3 = cast(u1, (x1 >> 256));
    out1.* = x2;
    out2.* = x3;
}

/// The function fiatBn254ScalarSubborrowxU256 is a subtraction with borrow.
///
/// Postconditions:
///   out1 = (-arg1 + arg2 + -arg3) mod 2^256
///   out2 = -⌊(-arg1 + arg2 + -arg3) / 2^256⌋
///
/// Input Bounds:
///   arg1: [0x0 ~> 0x1]
///   arg2: [0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]
///   arg3: [0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]
/// Output Bounds:
///   out1: [0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]
///   out2: [0x0 ~> 0x1]
pub fn fiatBn254ScalarSubborrowxU256(out1: *u256, out2: *u1, arg1: u1, arg2: u256, arg3: u256) void {
    @setRuntimeSafety(mode == .Debug);

    const x1 = ((cast(i512, arg2) - cast(i512, arg1)) - cast(i512, arg3));
    const x2 = cast(i1, (x1 >> 256));
    const x3 = cast(u256, (x1 & cast(i512, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)));
    out1.* = x3;
    out2.* = cast(u1, (cast(i2, 0x0) - cast(i2, x2)));
}

/// The function fiatBn254ScalarMulxU256 is a multiplication, returning the full double-width result.
///
/// Postconditions:
///   out1 = (arg1 * arg2) mod 2^256
///   out2 = ⌊arg1 * arg2 / 2^256⌋
///
/// Input Bounds:
///   arg1: [0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]
///   arg2: [0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]
/// Output Bounds:
///   out1: [0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]
///   out2: [0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]
pub fn fiatBn254ScalarMulxU256(out1: *u256, out2: *u256, arg1: u256, arg2: u256) void {
    @setRuntimeSafety(mode == .Debug);

    const x1 = (cast(u512, arg1) * cast(u512, arg2));
    const x2 = cast(u256, (x1 & cast(u512, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)));
    const x3 = cast(u256, (x1 >> 256));
    out1.* = x2;
    out2.* = x3;
}

/// The function fiatBn254ScalarCmovznzU256 is a single-word conditional move.
///
/// Postconditions:
///   out1 = (if arg1 = 0 then arg2 else arg3)
///
/// Input Bounds:
///   arg1: [0x0 ~> 0x1]
///   arg2: [0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]
///   arg3: [0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]
/// Output Bounds:
///   out1: [0x0 ~> 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff]
pub fn fiatBn254ScalarCmovznzU256(out1: *u256, arg1: u1, arg2: u256, arg3: u256) void {
    @setRuntimeSafety(mode == .Debug);

    const x1 = (~(~arg1));
    const x2 = cast(u256, (cast(i512, cast(i1, (cast(i2, 0x0) - cast(i2, x1)))) & cast(i512, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)));
    const x3 = ((x2 & arg3) | ((~x2) & arg2));
    out1.* = x3;
}

/// The function fiatBn254ScalarFromMontgomery translates a field element out of the Montgomery domain.
///
/// Preconditions:
///   0 ≤ eval arg1 < m
/// Postconditions:
///   eval out1 mod m = (eval arg1 * ((2^256)⁻¹ mod m)^1) mod m
///   0 ≤ eval out1 < m
///
pub fn fiatBn254ScalarFromMontgomery(out1: *FiatBn254ScalarNonMontgomeryDomainFieldElement, arg1: FiatBn254ScalarMontgomeryDomainFieldElement) void {
    @setRuntimeSafety(mode == .Debug);

    const x1 = (arg1[0]);
    var x2: u256 = undefined;
    var x3: u256 = undefined;
    fiatBn254ScalarMulxU256(&x2, &x3, x1, 0x73f82f1d0d8341b2e39a9828990623916586864b4c6911b3c2e1f593efffffff);
    var x4: u256 = undefined;
    var x5: u256 = undefined;
    fiatBn254ScalarMulxU256(&x4, &x5, x2, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001);
    var x6: u256 = undefined;
    var x7: u1 = undefined;
    fiatBn254ScalarAddcarryxU256(&x6, &x7, 0x0, x1, x4);
    const x8 = (cast(u256, x7) + x5);
    var x9: u256 = undefined;
    var x10: u1 = undefined;
    fiatBn254ScalarSubborrowxU256(&x9, &x10, 0x0, x8, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001);
    var x11: u256 = undefined;
    var x12: u1 = undefined;
    fiatBn254ScalarSubborrowxU256(&x11, &x12, x10, cast(u256, 0x0), cast(u256, 0x0));
    var x13: u256 = undefined;
    fiatBn254ScalarCmovznzU256(&x13, x12, x9, x8);
    out1[0] = x13;
}

/// The function fiatBn254ScalarToMontgomery translates a field element into the Montgomery domain.
///
/// Preconditions:
///   0 ≤ eval arg1 < m
/// Postconditions:
///   eval (from_montgomery out1) mod m = eval arg1 mod m
///   0 ≤ eval out1 < m
///
pub fn fiatBn254ScalarToMontgomery(out1: *FiatBn254ScalarMontgomeryDomainFieldElement, arg1: FiatBn254ScalarNonMontgomeryDomainFieldElement) void {
    @setRuntimeSafety(mode == .Debug);

    var x1: u256 = undefined;
    var x2: u256 = undefined;
    fiatBn254ScalarMulxU256(&x1, &x2, (arg1[0]), 0x216d0b17f4e44a58c49833d53bb808553fe3ab1e35c59e31bb8e645ae216da7);
    var x3: u256 = undefined;
    var x4: u256 = undefined;
    fiatBn254ScalarMulxU256(&x3, &x4, x1, 0x73f82f1d0d8341b2e39a9828990623916586864b4c6911b3c2e1f593efffffff);
    var x5: u256 = undefined;
    var x6: u256 = undefined;
    fiatBn254ScalarMulxU256(&x5, &x6, x3, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001);
    var x7: u256 = undefined;
    var x8: u1 = undefined;
    fiatBn254ScalarAddcarryxU256(&x7, &x8, 0x0, x1, x5);
    const x9 = ((cast(u256, x8) + x2) + x6);
    var x10: u256 = undefined;
    var x11: u1 = undefined;
    fiatBn254ScalarSubborrowxU256(&x10, &x11, 0x0, x9, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001);
    var x12: u256 = undefined;
    var x13: u1 = undefined;
    fiatBn254ScalarSubborrowxU256(&x12, &x13, x11, cast(u256, 0x0), cast(u256, 0x0));
    var x14: u256 = undefined;
    fiatBn254ScalarCmovznzU256(&x14, x13, x10, x9);
    out1[0] = x14;
}

/// The function fiatBn254ScalarAdd adds two field elements in the Montgomery domain.
///
/// Preconditions:
///   0 ≤ eval arg1 < m
///   0 ≤ eval arg2 < m
/// Postconditions:
///   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) + eval (from_montgomery arg2)) mod m
///   0 ≤ eval out1 < m
///
pub fn fiatBn254ScalarAdd(out1: *FiatBn254ScalarMontgomeryDomainFieldElement, arg1: FiatBn254ScalarMontgomeryDomainFieldElement, arg2: FiatBn254ScalarMontgomeryDomainFieldElement) void {
    @setRuntimeSafety(mode == .Debug);

    var x1: u256 = undefined;
    var x2: u1 = undefined;
    fiatBn254ScalarAddcarryxU256(&x1, &x2, 0x0, (arg1[0]), (arg2[0]));
    var x3: u256 = undefined;
    var x4: u1 = undefined;
    fiatBn254ScalarSubborrowxU256(&x3, &x4, 0x0, x1, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001);
    var x5: u256 = undefined;
    var x6: u1 = undefined;
    fiatBn254ScalarSubborrowxU256(&x5, &x6, x4, cast(u256, x2), cast(u256, 0x0));
    var x7: u256 = undefined;
    fiatBn254ScalarCmovznzU256(&x7, x6, x3, x1);
    out1[0] = x7;
}

/// The function fiatBn254ScalarMul multiplies two field elements in the Montgomery domain.
///
/// Preconditions:
///   0 ≤ eval arg1 < m
///   0 ≤ eval arg2 < m
/// Postconditions:
///   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg2)) mod m
///   0 ≤ eval out1 < m
///
pub fn fiatBn254ScalarMul(out1: *FiatBn254ScalarMontgomeryDomainFieldElement, arg1: FiatBn254ScalarMontgomeryDomainFieldElement, arg2: FiatBn254ScalarMontgomeryDomainFieldElement) void {
    @setRuntimeSafety(mode == .Debug);

    const x1 = (arg1[0]);
    var x2: u256 = undefined;
    var x3: u256 = undefined;
    fiatBn254ScalarMulxU256(&x2, &x3, x1, (arg2[0]));
    var x4: u256 = undefined;
    var x5: u256 = undefined;
    fiatBn254ScalarMulxU256(&x4, &x5, x2, 0x73f82f1d0d8341b2e39a9828990623916586864b4c6911b3c2e1f593efffffff);
    var x6: u256 = undefined;
    var x7: u256 = undefined;
    fiatBn254ScalarMulxU256(&x6, &x7, x4, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001);
    var x8: u256 = undefined;
    var x9: u1 = undefined;
    fiatBn254ScalarAddcarryxU256(&x8, &x9, 0x0, x2, x6);
    var x10: u256 = undefined;
    var x11: u1 = undefined;
    fiatBn254ScalarAddcarryxU256(&x10, &x11, x9, x3, x7);
    var x12: u256 = undefined;
    var x13: u1 = undefined;
    fiatBn254ScalarSubborrowxU256(&x12, &x13, 0x0, x10, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001);
    var x14: u256 = undefined;
    var x15: u1 = undefined;
    fiatBn254ScalarSubborrowxU256(&x14, &x15, x13, cast(u256, x11), cast(u256, 0x0));
    var x16: u256 = undefined;
    fiatBn254ScalarCmovznzU256(&x16, x15, x12, x10);
    out1[0] = x16;
}

/// The function fiatBn254ScalarSquare squares a field element in the Montgomery domain.
///
/// Preconditions:
///   0 ≤ eval arg1 < m
/// Postconditions:
///   eval (from_montgomery out1) mod m = (eval (from_montgomery arg1) * eval (from_montgomery arg1)) mod m
///   0 ≤ eval out1 < m
///
pub fn fiatBn254ScalarSquare(out1: *FiatBn254ScalarMontgomeryDomainFieldElement, arg1: FiatBn254ScalarMontgomeryDomainFieldElement) void {
    @setRuntimeSafety(mode == .Debug);

    const x1 = (arg1[0]);
    var x2: u256 = undefined;
    var x3: u256 = undefined;
    fiatBn254ScalarMulxU256(&x2, &x3, x1, (arg1[0]));
    var x4: u256 = undefined;
    var x5: u256 = undefined;
    fiatBn254ScalarMulxU256(&x4, &x5, x2, 0x73f82f1d0d8341b2e39a9828990623916586864b4c6911b3c2e1f593efffffff);
    var x6: u256 = undefined;
    var x7: u256 = undefined;
    fiatBn254ScalarMulxU256(&x6, &x7, x4, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001);
    var x8: u256 = undefined;
    var x9: u1 = undefined;
    fiatBn254ScalarAddcarryxU256(&x8, &x9, 0x0, x2, x6);
    var x10: u256 = undefined;
    var x11: u1 = undefined;
    fiatBn254ScalarAddcarryxU256(&x10, &x11, x9, x3, x7);
    var x12: u256 = undefined;
    var x13: u1 = undefined;
    fiatBn254ScalarSubborrowxU256(&x12, &x13, 0x0, x10, 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001);
    var x14: u256 = undefined;
    var x15: u1 = undefined;
    fiatBn254ScalarSubborrowxU256(&x14, &x15, x13, cast(u256, x11), cast(u256, 0x0));
    var x16: u256 = undefined;
    fiatBn254ScalarCmovznzU256(&x16, x15, x12, x10);
    out1[0] = x16;
}
